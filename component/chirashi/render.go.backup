package particle

import (
	"github.com/hajimehoshi/ebiten/v2"
	"github.com/yohamta/donburi"
	"github.com/yohamta/donburi/ecs"
	"github.com/yohamta/donburi/filter"
)

type Render struct {
	query *donburi.Query
}

func NewRender() *Render {
	return &Render{
		query: donburi.NewQuery(filter.Contains(Component)),
	}
}

func (r *Render) Draw(ecs *ecs.ECS, screen *ebiten.Image) {
	particleEntitiesCount := 0
	totalActiveParticles := 0

	for entry := range r.query.Iter(ecs.World) {
		p := Component.Get(entry)
		particleEntitiesCount++

		for _, particle := range p.ParticlePool {
			if !particle.Active {
				continue
			}
			totalActiveParticles++
			op := &ebiten.DrawImageOptions{}

			// Apply scale transformation
			if particle.Scale > 0 {
				op.GeoM.Scale(particle.Scale, particle.Scale)
			}

			// Apply rotation transformation
			if particle.Rotation != 0 {
				// Get image bounds for centering rotation
				bounds := p.SourceImage.Bounds()
				centerX := float64(bounds.Dx()) / 2
				centerY := float64(bounds.Dy()) / 2

				// Translate to center, rotate, then translate back
				op.GeoM.Translate(-centerX, -centerY)
				op.GeoM.Rotate(particle.Rotation)
				op.GeoM.Translate(centerX, centerY)
			}

			// Apply position transformation
			op.GeoM.Translate(particle.Position.X, particle.Position.Y)

			// Apply alpha transparency
			op.ColorScale.Scale(
				1*float32(particle.Alpha),
				1*float32(particle.Alpha),
				1*float32(particle.Alpha),
				float32(particle.Alpha),
			)
			op.CompositeMode = ebiten.CompositeModeLighter
			screen.DrawImage(p.SourceImage, op)
		}
	}
}
